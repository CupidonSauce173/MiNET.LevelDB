using System;
using System.Collections.Generic;
using System.IO;
using PigNet.LevelDB.Utils;

namespace PigNet.LevelDB
{
	public class BloomFilterPolicy
	{
		private int _bitsPerKey;
		private int _k;
		private int _baseLg;
		private int _startOffsetArray;
		private Memory<byte> _filterBlock;

		public BloomFilterPolicy(int bitsPerKey = 10)
		{
			_bitsPerKey = bitsPerKey;
			_k = (int) Math.Max(1, Math.Min(30, (bitsPerKey * 0.69)));
		}

		public string Name()
		{
			return "leveldb.BuiltinBloomFilter2";
		}

		public byte[] CreateFilter(List<byte[]> keys)
		{
			// Compute bloom filter size (in both bits and bytes)
			// For small n, we can see a very high false positive rate.
			// Fix it by enforcing a minimum bloom filter length.
			int bits = Math.Max(64, keys.Count * _bitsPerKey);
			int bytes = (int) ((bits + 7f) / 8f);
			bits = bytes * 8;

			byte[] array = new byte[bytes + 1];
			array[array.Length - 1] = (byte) _k; // Remember # of probes in filter

			foreach (var key in keys)
			{
				// Use double-hashing to generate a sequence of hash values.
				// See analysis in [Kirsch,Mitzenmacher 2006].
				uint h = BloomHash(key);
				uint delta = (h >> 17) | (h << 15); // Rotate right 17 bits
				for (int j = 0; j < _k; j++)
				{
					int bitpos = (int) (h % bits);
					array[bitpos / 8] |= (byte) (1 << (bitpos % 8));
					h += delta;
				}
			}

			return array;
		}

		private uint BloomHash(Span<byte> data)
		{
			return Hashing.Hash(data, 0xbc9f1d34); //avoid data copy
		}

		public bool KeyMayMatch(Span<byte> key, ulong position)
		{
			var num = (_filterBlock.Length - 5 - _startOffsetArray) / sizeof(int);
			int index = (int) (position >> _baseLg);
			if (index >= num)
			{
				return true; // Maybe even on errors
			}


			var start = BitConverter.ToInt32(_filterBlock.Slice(_startOffsetArray + index * sizeof(int), 4).Span);
			var limit = BitConverter.ToInt32(_filterBlock.Slice(_startOffsetArray + index * sizeof(int) + sizeof(int), 4).Span);

			if (start > limit || limit > _filterBlock.Length)
			{
				return false; // nothing in this filter, so don't match key
			}

			return KeyMayMatch(key, _filterBlock.Slice(start, limit - start).Span);
		}

		public bool KeyMayMatch(Span<byte> key, Span<byte> data)
		{
			int len = data.Length;
			if (len < 2)
			{
				return false;
			}

			int bits = (len - 1) * 8;

			// Use the encoded k so that we can read filters generated by
			// bloom filters created using different parameters.
			int k = data[len - 1];
			if (k > 30)
			{
				// Reserved for potentially new encodings for short bloom filters.
				// Consider it a match.
				return true;
			}

			uint h = BloomHash(key);
			uint delta = (h >> 17) | (h << 15); // Rotate right 17 bits
			for (int j = 0; j < k; j++)
			{
				int bitpos = (int) (h % bits);
				if ((data[bitpos / 8] & (1 << (bitpos % 8))) == 0)
				{
					return false;
				}
				h += delta;
			}

			return true;
		}

		/**
		* Convert an unsigned int into a long
		*/
		private long ToLong(uint h)
		{
			return h;
		}

		public object Parse(byte[] filterBlock)
		{
			var reader = new SpanReader(filterBlock);

			if (reader.Length < 5) return null;

			reader.Seek(-1, SeekOrigin.End);
			_baseLg = reader.ReadByte();
			reader.Seek(-5, SeekOrigin.End);
			_startOffsetArray = reader.ReadInt32();

			if (_startOffsetArray > reader.Length - 5) return null;

			_filterBlock = filterBlock;

			return null;
		}
	}
}